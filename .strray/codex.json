{
  "version": "1.2.25",
  "lastUpdated": "2026-01-16",
  "errorPreventionTarget": 0.996,
  "terms": {
    "1": {
      "number": 1,
      "title": "Progressive Prod-Ready Code",
      "description": "All code must be production-ready from the first commit. No placeholder, stub, or incomplete implementations. Every function, class, and module must be fully functional and ready for deployment.",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "2": {
      "number": 2,
      "title": "No Patches/Boiler/Stubs/Bridge Code",
      "description": "Prohibit: Temporary patches that are \"meant to be fixed later\", Boilerplate code that serves no real purpose, Stub implementations that don't function, Bridge code that creates unnecessary abstractions. All code must have clear, permanent purpose and complete implementation.",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "3": {
      "number": 3,
      "title": "Do Not Over-Engineer the Solution",
      "description": "Solutions should be: Simple and direct, Focused on the actual problem, Free of unnecessary abstractions, Maintainable and understandable, Minimal complexity for the required functionality",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "4": {
      "number": 4,
      "title": "Fit for Purpose and Prod-Level Code",
      "description": "Every piece of code must: Solve the specific problem it was created for, Meet production standards (error handling, logging, monitoring), Be maintainable by other developers, Follow established patterns in the codebase, Include appropriate tests",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "5": {
      "number": 5,
      "title": "Surgical Fixes Where Needed",
      "description": "Apply precise, targeted fixes: Fix the root cause, not symptoms, Make minimal changes to resolve the issue, Avoid refactoring unrelated code, Preserve existing functionality, Document the fix clearly",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "6": {
      "number": 6,
      "title": "Batched Introspection Cycles",
      "description": "Group introspection and analysis into intentional cycles: Review code in batches, not line-by-line, Combine related improvements, Avoid micro-optimizations during development, Schedule dedicated refactoring sessions, Focus on meaningful architectural improvements",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "low"
    },
    "7": {
      "number": 7,
      "title": "Resolve All Errors (90% Runtime Prevention)",
      "description": "Zero-tolerance for unresolved errors: All errors must be resolved before proceeding, No console.log debugging or ignored errors, Systematic error handling with proper recovery, Error prevention through type safety and validation, 90% of runtime errors prevented through systematic checks",
      "category": "core",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "8": {
      "number": 8,
      "title": "Prevent Infinite Loops",
      "description": "Guarantee termination in all iterative processes: All loops must have clear termination conditions, Recursive functions must have base cases, Event loops must have exit strategies, Async operations must have timeout mechanisms, All indefinite iteration patterns must be prohibited",
      "category": "core",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "9": {
      "number": 9,
      "title": "Use Shared Global State Where Possible",
      "description": "Prefer shared state over duplicated state: Single source of truth for data, Centralized state management, Avoid prop-drilling or passing data through multiple layers, Use React Context, Redux, or similar patterns appropriately, Reduce state duplication and synchronization issues",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "10": {
      "number": 10,
      "title": "Single Source of Truth",
      "description": "Maintain one authoritative source for each piece of information: Configuration stored in one place, Data models defined once, API contracts specified in a single location, Documentation references the actual code, Avoid duplication and contradictory information",
      "category": "core",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "11": {
      "number": 11,
      "title": "Type Safety First",
      "description": "Never use any, @ts-ignore, or @ts-expect-error, Leverage TypeScript's type system fully, Use discriminated unions for complex state, Prefer type inference over explicit types when appropriate, Type errors are blocking issues",
      "category": "extended",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "12": {
      "number": 12,
      "title": "Early Returns and Guard Clauses",
      "description": "Validate inputs at function boundaries, Return early for invalid conditions, Reduce nesting with guard clauses, Keep the happy path at the top level, Improve readability and reduce cognitive load",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "13": {
      "number": 13,
      "title": "Error Boundaries and Graceful Degradation",
      "description": "Wrap components in error boundaries, Provide fallback UI when components fail, Implement circuit breakers for external dependencies, Log errors for debugging without crashing, Maintain user experience during failures",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "14": {
      "number": 14,
      "title": "Immutability Where Possible",
      "description": "Prefer const over let, Use immutable data structures, Avoid mutating function parameters, Use spread operator or array methods instead of mutation, Predictable state changes are easier to debug",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "15": {
      "number": 15,
      "title": "Separation of Concerns",
      "description": "Keep UI separate from business logic, Separate data fetching from rendering, Isolate side effects (API calls, logging), Clear boundaries between layers (UI, logic, data), Each component/module has one responsibility",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "16": {
      "number": 16,
      "title": "DRY - Don't Repeat Yourself",
      "description": "Extract repeated logic into reusable functions, Use composition over inheritance, Create shared utilities for common operations, Avoid copy-pasting code, Maintain consistency through shared code",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "17": {
      "number": 17,
      "title": "YAGNI - You Aren't Gonna Need It",
      "description": "Don't implement features that aren't needed now, Avoid \"just in case\" code, Build for current requirements, not hypothetical ones, Defer optimization until there's a measurable problem, Keep codebase lean and focused",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "18": {
      "number": 18,
      "title": "Meaningful Naming",
      "description": "Variables, functions, and classes should be self-documenting, Avoid abbreviations unless widely understood, Use verbs for functions (calculatePrice, fetchUserData), Use nouns for classes (UserService, PriceCalculator), Boolean variables should be clear (isLoading, hasError)",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "19": {
      "number": 19,
      "title": "Small, Focused Functions",
      "description": "Each function should do one thing well, Keep functions under 20-30 lines when possible, Reduce complexity by breaking down large functions, Pure functions are easier to test and understand, Side effects should be explicit and isolated",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "20": {
      "number": 20,
      "title": "Consistent Code Style",
      "description": "Follow existing patterns in the codebase, Use linters and formatters (ESLint, Prettier), Maintain consistent formatting throughout, Follow language idioms (TypeScript best practices), Code should read like it was written by one person",
      "category": "extended",
      "zeroTolerance": false,
      "enforcementLevel": "low"
    },
    "21": {
      "number": 21,
      "title": "Dependency Injection",
      "description": "Pass dependencies as parameters, Avoid hardcoded dependencies, Make code testable by injecting mocks, Use inversion of control containers when beneficial, Reduce coupling between components",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "22": {
      "number": 22,
      "title": "Interface Segregation",
      "description": "Define specific, focused interfaces, Avoid god interfaces with too many methods, Clients shouldn't depend on methods they don't use, Split large interfaces into smaller, specific ones, Improve testability and flexibility",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "23": {
      "number": 23,
      "title": "Open/Closed Principle",
      "description": "Open for extension, closed for modification, Use polymorphism to add new behavior, Avoid changing existing code when adding features, Plugin and extension patterns, Maintain stability while enabling growth",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "24": {
      "number": 24,
      "title": "Single Responsibility Principle",
      "description": "Each class/module should have one reason to change, Separate concerns into different modules, Keep functions focused on one task, Reduce coupling between components, Make code easier to test and maintain",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "25": {
      "number": 25,
      "title": "Code Rot Prevention",
      "description": "Monitor code consolidation (>70% consolidation threshold), Refactor code that has grown organically, Remove unused code and dependencies, Update deprecated APIs and patterns, Maintain code quality over time",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "26": {
      "number": 26,
      "title": "Test Coverage >85%",
      "description": "Maintain 85%+ behavioral test coverage, Focus on behavior, not implementation details, Integration tests for critical paths, Unit tests for pure functions and utilities, E2E tests for user workflows",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "27": {
      "number": 27,
      "title": "Fast Feedback Loops",
      "description": "Provide immediate validation feedback, Show loading states for async operations, Real-time error messages for forms, Clear success confirmation after actions, Reduce user uncertainty",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "28": {
      "number": 28,
      "title": "Performance Budget Enforcement",
      "description": "Bundle size <2MB (gzipped <700KB), First Contentful Paint <2s, Time to Interactive <5s, Lazy load non-critical components, Optimize images and assets",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "29": {
      "number": 29,
      "title": "Security by Design",
      "description": "Validate all inputs (client and server), Sanitize data before rendering, Use HTTPS for all requests, Implement rate limiting, Never expose sensitive data in client code",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "30": {
      "number": 30,
      "title": "Accessibility First",
      "description": "Semantic HTML elements, ARIA labels for interactive elements, Keyboard navigation support, Screen reader compatibility, WCAG 2.1 AA compliance",
      "category": "architecture",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "31": {
      "number": 31,
      "title": "Async/Await Over Callbacks",
      "description": "Use async/await for asynchronous code, Avoid callback hell, Proper error handling with try/catch, Parallel async operations with Promise.all, Sequential async operations when dependencies exist",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "32": {
      "number": 32,
      "title": "Proper Error Handling",
      "description": "Never ignore errors (no empty catch blocks), Provide context in error messages, Log errors for debugging, Inform users of actionable errors, Implement retry logic for transient failures",
      "category": "advanced",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "33": {
      "number": 33,
      "title": "Logging and Monitoring",
      "description": "Log important events and errors, Use structured logging (JSON), Monitor performance metrics, Set up error tracking (Sentry, LogRocket), Production debugging visibility",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "34": {
      "number": 34,
      "title": "Documentation Updates",
      "description": "Update README when adding features, Document API endpoints and contracts, Include inline comments for complex logic, Keep architecture diagrams current, Document breaking changes",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "35": {
      "number": 35,
      "title": "Version Control Best Practices",
      "description": "Atomic commits (one logical change per commit), Descriptive commit messages, Use feature branches, Pull requests for code review, Maintain clean git history",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "36": {
      "number": 36,
      "title": "Continuous Integration",
      "description": "Automated testing on every commit, Linting and formatting checks, Build verification, Deploy previews for review, Fast feedback on quality",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "37": {
      "number": 37,
      "title": "Configuration Management",
      "description": "Environment variables for secrets, Config files for environment-specific settings, Never commit secrets to version control, Validate configuration on startup, Default values with overrides",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "38": {
      "number": 38,
      "title": "Functionality Retention",
      "description": "Preserve existing functionality when refactoring, Regression testing before changes, 99.7% functionality retention rate, Migration paths for breaking changes, Backward compatibility when possible",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "39": {
      "number": 39,
      "title": "Gradual Refactoring",
      "description": "Refactor in small, testable steps, Maintain working code throughout, Each refactoring improves specific aspect, Don't rewrite entire systems at once, Continuous improvement mindset",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "40": {
      "number": 40,
      "title": "Modular Design",
      "description": "Clear module boundaries, Low coupling, high cohesion, Reusable components, Pluggable architecture, Easy to test individual modules",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "41": {
      "number": 41,
      "title": "State Management Patterns",
      "description": "Choose appropriate state management (Context API, Redux, Zustand), Keep state as close to where it's used as possible, Minimize global state, Derive computed state from base state, Normalize complex state",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "42": {
      "number": 42,
      "title": "Code Review Standards",
      "description": "At least one reviewer for all changes, Focus on correctness, not style, Verify tests are added/updated, Check documentation updates, Maintain quality standards",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "43": {
      "number": 43,
      "title": "Deployment Safety",
      "description": "Zero-downtime deployments, Feature flags for risky changes, Rollback capability for quick recovery, Monitor deployments closely, Gradual rollout to production",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "high"
    },
    "44": {
      "number": 44,
      "title": "Infrastructure as Code Validation",
      "description": "All infrastructure and configuration files must be validated before deployment: YAML/JSON syntax validation for CI/CD workflows, Configuration file linting and formatting, Automated validation in pre-commit hooks, Schema validation for configuration files, No manual YAML debugging - validate early and often",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "45": {
      "number": 45,
      "title": "Test Execution Optimization",
      "description": "Test execution must be optimized for speed and reliability: Run unit tests with multiple workers (minimum 4 threads), Run E2E tests with parallel workers (minimum 4 workers), Implement chunked output processing for large test results, Stop execution if 5+ tests fail (triage threshold), Use sub-agents for handling large test outputs (>30k characters), Large test suites (>50 files) must use intelligent chunking with 30-second timeouts per chunk, Automatic fallback to individual test execution for suites exceeding 10-minute total runtime, Test suite size limits: maximum 100 files per suite, implement parallel chunk execution with progress monitoring",
      "category": "advanced",
      "zeroTolerance": false,
      "enforcementLevel": "medium"
    },
    "46": {
      "number": 46,
      "title": "System Integrity Cross-Check",
      "description": "All framework components must validate their integration with dependent systems during initialization. Critical components must implement integrity checks that verify: All required dependencies are available and functional, Integration interfaces work correctly, Component state is consistent across execution contexts (boot, plugin, runtime), Cross-context dependencies are properly shared, Automated remediation attempts missing components, Comprehensive logging of integration status and failures",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "47": {
      "number": 47,
      "title": "Integration Testing Mandate",
      "description": "All new features and components must include integration tests using real dependencies, not mocks. Integration tests must validate: End-to-end functionality across component boundaries, Cross-context interactions (boot/plugin/runtime), Real dependency injection and resolution, Environment-specific behavior validation, Performance impact on integrated systems. Mock-based tests are insufficient for integration validation",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "48": {
      "number": 48,
      "title": "Path Resolution Abstraction",
      "description": "All file and module paths must use abstracted resolution systems, never hardcoded paths. Path resolution must support: Multiple execution environments (development/build/deployed), Cross-platform compatibility (Windows/macOS/Linux), Dynamic path construction based on runtime context, Centralized path management systems, Automatic fallback mechanisms for path resolution failures",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "49": {
      "number": 49,
      "title": "Feature Completeness Validation",
      "description": "No feature is considered complete until it passes comprehensive integration validation. Features must demonstrate: Full integration with dependent systems, Functional end-to-end workflows, Cross-environment compatibility, Performance within acceptable budgets, Documentation completeness, Test coverage including integration scenarios. Partial implementations are not permitted",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "50": {
      "number": 50,
      "title": "Architecture Review Requirements",
      "description": "All new components, features, and architectural changes require formal architecture review. Reviews must validate: System integration impact assessment, Cross-cutting concern compliance, Performance and scalability implications, Security consideration completeness, Maintenance and extensibility evaluation, Alignment with overall system architecture. Reviews must be conducted before implementation begins",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "46": {
      "number": 46,
      "title": "System Integrity Cross-Check",
      "description": "All framework components must validate their integration with dependent systems during initialization. Critical components must implement integrity checks that verify: All required dependencies are available and functional, Integration interfaces work correctly, Component state is consistent across execution contexts (boot, plugin, runtime), Cross-context dependencies are properly shared, Automated remediation attempts missing components, Comprehensive logging of integration status and failures",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "47": {
      "number": 47,
      "title": "Integration Testing Mandate",
      "description": "All new features and components must include integration tests using real dependencies, not mocks. Integration tests must validate: End-to-end functionality across component boundaries, Cross-context interactions (boot/plugin/runtime), Real dependency injection and resolution, Environment-specific behavior validation, Performance impact on integrated systems. Mock-based tests are insufficient for integration validation",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "48": {
      "number": 48,
      "title": "Path Resolution Abstraction",
      "description": "All file and module paths must use abstracted resolution systems, never hardcoded paths. Path resolution must support: Multiple execution environments (development/build/deployed), Cross-platform compatibility (Windows/macOS/Linux), Dynamic path construction based on runtime context, Centralized path management systems, Automatic fallback mechanisms for path resolution failures",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "49": {
      "number": 49,
      "title": "Feature Completeness Validation",
      "description": "No feature is considered complete until it passes comprehensive integration validation. Features must demonstrate: Full integration with dependent systems, Functional end-to-end workflows, Cross-environment compatibility, Performance within acceptable budgets, Documentation completeness, Test coverage including integration scenarios. Partial implementations are not permitted",
      "category": "architectural",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "51": {
      "number": 51,
      "title": "Self-Evolution Safety Framework",
      "description": "Autonomous self-improvement systems must implement comprehensive safety mechanisms: Version consistency across all codex references, Learning rate limits to prevent destabilization, Human oversight gates for major changes, Causal inference confidence thresholds, Progressive escalation for trend monitoring, Automated remediation with rollback capabilities, Continuous validation of self-modification safety",
      "category": "self-evolution",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "52": {
      "number": 52,
      "title": "CI/CD Pipeline Enforcement (ZERO TOLERANCE)",
      "description": "Commits cannot be pushed to remote unless code compiles and all tests pass: Code must compile successfully, All tests must pass (unit, integration, E2E), No TypeScript compilation errors allowed, Pre-commit hooks must validate compilation and test execution before push",
      "category": "ci-cd",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "53": {
      "number": 53,
      "title": "NPM Package Publishing Compliance",
      "description": "NPM package cannot be published unless CI/CD pipeline is verified passing: Full test suite must pass (unit, integration, E2E), Build process must complete successfully, Security scans must pass without critical vulnerabilities, No manual publishing - automated deployment only",
      "category": "ci-cd",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "54": {
      "number": 54,
      "title": "Version Bumping Restrictions",
      "description": "Versions are only bumped upon release when CI/CD pipeline is verified passing: Version bumps occur only during formal releases, Never bump versions for bug fixes or intermediate commits, Release process requires full CI/CD validation, Semantic versioning strictly enforced (MAJOR.MINOR.PATCH), No pre-release version bumps without pipeline approval",
      "category": "ci-cd",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    },
    "55": {
      "number": 55,
      "title": "Framework Command Orchestration",
      "description": "Pipeline operations must use framework commands for orchestration: All CI/CD operations must use 'strray' framework commands, Direct AI execution outside framework is prohibited, Use 'strray release', 'strray deploy', 'strray validate' commands, Framework handles complexity analysis and agent delegation, Direct tool calls bypass orchestration and violate compliance",
      "category": "ci-cd",
      "zeroTolerance": true,
      "enforcementLevel": "blocking"
    }
  },
  "interweaves": [
    "Error Prevention Interweave",
    "Performance Interweave",
    "Security Interweave"
  ],
  "lenses": ["Code Quality Lens", "Maintainability Lens", "Performance Lens"],
  "principles": ["SOLID Principles", "DRY Principles", "KISS Principles"],
  "antiPatterns": [
    "Spaghetti code",
    "Lasagna code",
    "Ravioli code",
    "Tight coupling",
    "Circular dependencies",
    "Golden hammer",
    "Cowboy coding",
    "Analysis paralysis",
    "Cargo cult programming",
    "Resume-driven development"
  ],
  "validationCriteria": {
    "All functions have implementations": false,
    "No TODO comments in production code": false,
    "All error paths are handled": false,
    "Edge cases are covered": false,
    "Logging is appropriate": false,
    "Linter passes without errors": false,
    "TypeScript compilation succeeds": false,
    "Tests pass (unit, integration, E2E)": false,
    "Bundle size within limits": false,
    "Performance meets targets": false,
    "No security vulnerabilities": false,
    "No type errors or any usage": false,
    "Input validation on all inputs": false,
    "Error handling in all async operations": false,
    "Proper secrets management": false
  },
  "frameworkAlignment": {
    "oh-my-opencode": "v2.12.0",
    "strray-framework": "v1.0.27"
  }
}
