"""CodexLoader: Load and validate Universal Development Codex terms.

This module provides lazy loading, LRU caching, and comprehensive validation
for the 43 codex terms defined in .strray/agents_template.md.
"""

import re
import json
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union
from enum import Enum

import structlog

logger = structlog.get_logger(__name__)


class CodexTerm:
    """Represents a single codex term with its metadata."""

    def __init__(
        self,
        term_id: int,
        title: str,
        content: str,
        category: str,
        subsection: Optional[str] = None
    ):
        self.term_id = term_id
        self.title = title
        self.content = content
        self.category = category
        self.subsection = subsection

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "term_id": self.term_id,
            "title": self.title,
            "content": self.content,
            "category": self.category,
            "subsection": self.subsection,
        }


class CodexCategory(Enum):
    """Codex term categories."""

    CORE = "Core Terms (1-10)"
    EXTENDED = "Extended Terms (11-20)"
    ARCHITECTURE = "Architecture Terms (21-30)"
    ADVANCED = "Advanced Terms (31-43)"


class CodexViolationError(Exception):
    """Raised when a codex violation is detected."""

    def __init__(self, term_id: int, term_title: str, message: str):
        self.term_id = term_id
        self.term_title = term_title
        self.message = message
        super().__init__(f"Codex violation for term {term_id} ({term_title}): {message}")


@dataclass
class CodexRule:
    """Represents a codex validation rule."""

    term_id: int
    title: str
    pattern: str
    severity: str = "medium"
    category: str = "general"
    cwe: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "term_id": self.term_id,
            "title": self.title,
            "pattern": self.pattern,
            "severity": self.severity,
            "category": self.category,
            "cwe": self.cwe,
        }


@dataclass
class CodexComplianceResult:
    """Result of a codex compliance check."""

    is_compliant: bool
    violations: List[Dict[str, Any]]
    term_id: Optional[int] = None
    term_title: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "is_compliant": self.is_compliant,
            "violations": self.violations,
            "term_id": self.term_id,
            "term_title": self.term_title,
        }


# Alias for test compatibility
CodexError = CodexViolationError


class CodexLoader:
    """Loads and validates the Universal Development Codex.

    Features:
    - Lazy loading with LRU caching
    - Comprehensive term parsing (all 43 terms)
    - Validation and compliance checking
    - Error handling and fallback mechanisms
    - Automatic reload on file changes
    """

    def __init__(
        self,
        codex_path: Optional[Path] = None,
        cache_ttl_seconds: int = 3600,
        auto_reload_on_change: bool = True,
    ):
        """Initialize CodexLoader.

        Args:
            codex_path: Path to codex markdown file. Defaults to .strray/agents_template.md
            cache_ttl_seconds: Time-to-live for cached codex data
            auto_reload_on_change: Automatically reload if file changes
        """
        self.codex_path = codex_path or self._find_codex_path()
        self.cache_ttl_seconds = cache_ttl_seconds
        self.auto_reload_on_change = auto_reload_on_change

        # Internal state
        self._codex_terms: Dict[int, CodexTerm] = {}
        self._categories: Dict[str, List[int]] = {}
        self._version: Optional[str] = None
        self._last_load_time: float = 0.0
        self._last_file_mtime: float = 0.0

        # Preload codex if file exists
        if self.codex_path and self.codex_path.exists():
            self._load_codex()

        logger.info(
            "CodexLoader initialized",
            codex_path=str(self.codex_path),
            version=self._version,
            terms_loaded=len(self._codex_terms),
        )

    def _find_codex_path(self) -> Optional[Path]:
        """Find codex file in standard locations."""
        candidates = [
            Path.cwd() / ".strray" / "agents_template.md",
            Path(__file__).parent.parent.parent / ".strray" / "agents_template.md",
            Path.home() / ".strray" / "agents_template.md",
        ]

        for path in candidates:
            if path.exists():
                logger.debug("Found codex file", path=str(path))
                return path

        logger.warning("Codex file not found in standard locations")
        return None

    def _load_codex(self) -> None:
        """Load codex terms from markdown file."""
        if not self.codex_path or not self.codex_path.exists():
            logger.warning("Codex file not available")
            return

        try:
            with open(self.codex_path, "r", encoding="utf-8") as f:
                content = f.read()

            # Check if reload is needed
            if self.auto_reload_on_change:
                current_mtime = self.codex_path.stat().st_mtime
                if current_mtime > self._last_file_mtime:
                    logger.debug("Codex file changed, reloading")
                    self._last_file_mtime = current_mtime
                elif time.time() - self._last_load_time < self.cache_ttl_seconds:
                    # Cache still valid
                    return

            # Parse version
            self._version = self._extract_version(content)

            # Extract all terms
            self._codex_terms = self._parse_terms(content)
            self._categories = self._categorize_terms(self._codex_terms)
            self._last_load_time = time.time()

            logger.info(
                "Codex loaded successfully",
                version=self._version,
                terms_count=len(self._codex_terms),
            )

        except Exception as e:
            logger.error("Failed to load codex", error=str(e), path=str(self.codex_path))
            # Keep existing cached data if load fails

    def _extract_version(self, content: str) -> Optional[str]:
        """Extract version from codex content."""
        match = re.search(r"\*\*Version\*\*:\s*([\d.]+)", content)
        return match.group(1) if match else None

    def _parse_terms(self, content: str) -> Dict[int, CodexTerm]:
        """Parse all codex terms from markdown content."""
        terms = {}

        # Find all term definitions using regex
        # Pattern matches: "#### N. Title" followed by content until next heading
        pattern = r"####\s+(\d+)\.\s+([^\n]+)\n\n(.*?)(?=\n####\s+\d+\.|\n###\s+|$)"
        matches = re.findall(pattern, content, re.DOTALL)

        for match in matches:
            term_id = int(match[0])
            title = match[1].strip()
            term_content = match[2].strip()

            # Determine category based on term_id
            if term_id <= 10:
                category = CodexCategory.CORE.value
            elif term_id <= 20:
                category = CodexCategory.EXTENDED.value
            elif term_id <= 30:
                category = CodexCategory.ARCHITECTURE.value
            else:
                category = CodexCategory.ADVANCED.value

            terms[term_id] = CodexTerm(
                term_id=term_id,
                title=title,
                content=term_content,
                category=category,
            )

        # Fallback: try to find terms with different patterns if regex failed
        if not terms:
            terms = self._parse_terms_fallback(content)

        logger.debug("Parsed codex terms", count=len(terms))
        return terms

    def _parse_terms_fallback(self, content: str) -> Dict[int, CodexTerm]:
        """Fallback parsing method for different markdown structures."""
        terms = {}
        lines = content.split("\n")
        current_term_id = None
        current_title = None
        current_content = []
        current_category = None

        for line in lines:
            # Detect term headers
            term_match = re.match(r"####\s+(\d+)\.\s+(.+)", line)
            if term_match:
                # Save previous term
                if current_term_id is not None:
                    category = current_category or CodexCategory.CORE.value
                    terms[current_term_id] = CodexTerm(
                        term_id=current_term_id,
                        title=current_title,
                        content="\n".join(current_content).strip(),
                        category=category,
                    )

                # Start new term
                current_term_id = int(term_match.group(1))
                current_title = term_match.group(2).strip()
                current_content = []
                
                # Update category
                if current_term_id <= 10:
                    current_category = CodexCategory.CORE.value
                elif current_term_id <= 20:
                    current_category = CodexCategory.EXTENDED.value
                elif current_term_id <= 30:
                    current_category = CodexCategory.ARCHITECTURE.value
                else:
                    current_category = CodexCategory.ADVANCED.value
            elif current_term_id is not None and line.strip():
                # Skip empty lines and other headers
                if not line.startswith("##") and not line.startswith("###"):
                    current_content.append(line)

        # Save last term
        if current_term_id is not None:
            category = current_category or CodexCategory.CORE.value
            terms[current_term_id] = CodexTerm(
                term_id=current_term_id,
                title=current_title,
                content="\n".join(current_content).strip(),
                category=category,
            )

        logger.debug("Fallback parsing found terms", count=len(terms))
        return terms

    def _categorize_terms(self, terms: Dict[int, CodexTerm]) -> Dict[str, List[int]]:
        """Group term IDs by category."""
        categories = {}
        for term_id, term in terms.items():
            if term.category not in categories:
                categories[term.category] = []
            categories[term.category].append(term_id)
        return categories

    @property
    def is_loaded(self) -> bool:
        """Check if codex has been loaded successfully."""
        return len(self._codex_terms) > 0

    @property
    def term_count(self) -> int:
        """Get total number of loaded terms."""
        return len(self._codex_terms)

    @property
    def version(self) -> Optional[str]:
        """Get codex version."""
        return self._version

    def get_term(self, term_id: int) -> Optional[CodexTerm]:
        """Get a specific codex term by ID.

        Args:
            term_id: Term identifier (1-43)

        Returns:
            CodexTerm if found, None otherwise
        """
        # Reload if needed
        if self.auto_reload_on_change and self.codex_path:
            if self.codex_path.stat().st_mtime > self._last_file_mtime:
                self._load_codex()

        return self._codex_terms.get(term_id)

    def get_term_by_title(self, title: str) -> Optional[CodexTerm]:
        """Get a codex term by title (case-insensitive partial match).

        Args:
            title: Title to search for

        Returns:
            CodexTerm if found, None otherwise
        """
        title_lower = title.lower()
        for term in self._codex_terms.values():
            if title_lower in term.title.lower():
                return term
        return None

    def search_terms(self, query: str) -> List[CodexTerm]:
        """Search codex terms by content.

        Args:
            query: Search query string

        Returns:
            List of matching CodexTerm objects
        """
        query_lower = query.lower()
        matches = []

        for term in self._codex_terms.values():
            # Search in title and content
            if (
                query_lower in term.title.lower()
                or query_lower in term.content.lower()
            ):
                matches.append(term)

        return matches

    def get_category_terms(self, category: str) -> List[CodexTerm]:
        """Get all terms in a specific category.

        Args:
            category: Category name (e.g., "Core Terms (1-10)")

        Returns:
            List of CodexTerm objects in the category
        """
        term_ids = self._categories.get(category, [])
        return [self._codex_terms[tid] for tid in term_ids if tid in self._codex_terms]

    def validate_compliance(
        self,
        code_or_action: Union[str, Dict[str, Any]],
        relevant_terms: Optional[List[int]] = None,
    ) -> List[CodexComplianceResult]:
        """Validate code or action against codex terms.

        Args:
            code_or_action: Code snippet, action description, or context dictionary to validate
            relevant_terms: Optional list of term IDs to check. If None, checks all terms.

        Returns:
            List of CodexComplianceResult objects with compliance status and violations
        """
        violations = []

        # Determine which terms to check
        terms_to_check = []
        if relevant_terms:
            terms_to_check = [self._codex_terms[tid] for tid in relevant_terms if tid in self._codex_terms]
        else:
            terms_to_check = list(self._codex_terms.values())

        # Check each term for violations
        for term in terms_to_check:
            violation = self._check_term_violation(code_or_action, term)
            if violation:
                violations.append(violation)

        is_compliant = len(violations) == 0

        if not is_compliant:
            logger.warning(
                "Codex violations detected",
                violations_count=len(violations),
                violation_ids=[v["term_id"] for v in violations],
            )

        # Return list of CodexComplianceResult objects
        results = []
        if relevant_terms:
            # Return results for specific terms
            for term_id in relevant_terms:
                if term_id in self._codex_terms:
                    term = self._codex_terms[term_id]
                    term_violations = [v for v in violations if v["term_id"] == term_id]
                    results.append(CodexComplianceResult(
                        is_compliant=len(term_violations) == 0,
                        violations=term_violations,
                        term_id=term_id,
                        term_title=term.title
                    ))
        else:
            # Return results for all loaded terms (for compatibility with tests)
            if len(self._codex_terms) > 0:
                for term_id, term in self._codex_terms.items():
                    term_violations = [v for v in violations if v["term_id"] == term_id]
                    results.append(CodexComplianceResult(
                        is_compliant=len(term_violations) == 0,
                        violations=term_violations,
                        term_id=term_id,
                        term_title=term.title
                    ))
            else:
                # Fallback: return single result for all terms
                results.append(CodexComplianceResult(
                    is_compliant=is_compliant,
                    violations=violations
                ))

        return results

    def _check_term_violation(
        self, code_or_action: Union[str, Dict[str, Any]], term: CodexTerm
    ) -> Optional[Dict[str, Any]]:
        """Check if code/action violates a specific codex term.

        Args:
            code_or_action: Code or action to check
            term: Codex term to validate against

        Returns:
            Violation dictionary if violation found, None otherwise
        """
        # Convert input to string for processing
        if isinstance(code_or_action, dict):
            content_str = str(code_or_action)
        else:
            content_str = code_or_action
        content_lower = content_str.lower()

        # Term-specific violation checks
        checks = self._get_violation_checks()

        if term.term_id in checks:
            check_func = checks[term.term_id]
            return check_func(content_lower, term)

        # Default: simple keyword-based check
        if term.term_id <= 10:  # Core terms have stricter enforcement
            keywords = self._extract_keywords(term.content)
            for keyword in keywords:
                if keyword.lower() in content_lower:
                    return {
                        "term_id": term.term_id,
                        "term_title": term.title,
                        "severity": "high",
                        "message": f"Potential violation of core term {term.term_id}: {term.title}",
                        "matched_keyword": keyword,
                    }

        return None

    def _get_violation_checks(self) -> Dict[int, callable]:
        """Get violation check functions for specific terms."""
        return {
            1: self._check_progressive_prod_ready,
            2: self._check_no_patches_boiler_stubs,
            3: self._check_no_over_engineering,
            7: self._check_resolve_all_errors,
            8: self._check_prevent_infinite_loops,
            11: self._check_type_safety,
            15: self._check_separation_of_concerns,
            17: self._check_yagni,
        }

    def _extract_keywords(self, content: str) -> List[str]:
        """Extract keywords from codex term content for validation."""
        # Simple extraction: find words in all caps or quotes
        keywords = []

        # Extract quoted terms
        quoted = re.findall(r'"([^"]+)"', content)
        keywords.extend(quoted)

        # Extract capitalized warning terms
        warnings = re.findall(r"\b(Prohibit|Never|Always|Must)\b", content)
        keywords.extend(warnings)

        return keywords[:10]  # Limit to top 10 keywords

    def _check_progressive_prod_ready(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for placeholder or incomplete code."""
        violations = [
            "TODO", "FIXME", "XXX", "HACK",
            "// placeholder", "// stub", "// fix later",
            "# placeholder", "# stub",
            "NotImplementedError", "pass  # TODO",
        ]

        for violation in violations:
            if violation.lower() in content:
                return {
                    "term_id": term.term_id,
                    "term_title": term.title,
                    "severity": "high",
                    "message": f"Placeholder or incomplete code detected: {violation}",
                    "matched_text": violation,
                }
        return None

    def _check_no_patches_boiler_stubs(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for temporary patches, boilerplate, or stubs."""
        violations = [
            "temporary patch", "temporary fix", "quick fix",
            "boilerplate", "stub implementation",
            "// bridge", "# bridge",
        ]

        for violation in violations:
            if violation.lower() in content:
                return {
                    "term_id": term.term_id,
                    "term_title": term.title,
                    "severity": "high",
                    "message": f"Patch/boilerplate/stub code detected: {violation}",
                    "matched_text": violation,
                }
        return None

    def _check_no_over_engineering(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for over-engineering patterns."""
        # This is harder to detect automatically
        # Look for excessive abstraction layers
        if content.count("abstract") > 3 or content.count("interface") > 5:
            return {
                "term_id": term.term_id,
                "term_title": term.title,
                "severity": "medium",
                "message": "Potential over-engineering: excessive abstraction layers detected",
            }
        return None

    def _check_resolve_all_errors(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for unresolved errors or improper error handling."""
        violations = [
            "console.log", "print(",  # Debugging statements
            "pass  # error",  # Ignored errors
            "except:",  # Bare except
            "except Exception:",  # Generic exception handling
        ]

        for violation in violations:
            if violation.lower() in content:
                return {
                    "term_id": term.term_id,
                    "term_title": term.title,
                    "severity": "high",
                    "message": f"Unresolved error or improper error handling: {violation}",
                    "matched_text": violation,
                }
        return None

    def _check_prevent_infinite_loops(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for potential infinite loops."""
        # Look for while True or similar patterns without breaks
        if "while True" in content and "break" not in content:
            return {
                "term_id": term.term_id,
                "term_title": term.title,
                "severity": "high",
                "message": "Potential infinite loop detected: while True without break",
            }

        if "while 1" in content and "break" not in content:
            return {
                "term_id": term.term_id,
                "term_title": term.title,
                "severity": "high",
                "message": "Potential infinite loop detected: while 1 without break",
            }

        return None

    def _check_type_safety(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for type safety violations."""
        violations = [
            "any", "any(", "any[",  # Using 'any' type
            "@ts-ignore", "@ts-expect-error",  # TypeScript ignores
        ]

        for violation in violations:
            if violation.lower() in content:
                return {
                    "term_id": term.term_id,
                    "term_title": term.title,
                    "severity": "high",
                    "message": f"Type safety violation: {violation}",
                    "matched_text": violation,
                }
        return None

    def _check_separation_of_concerns(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for separation of concerns violations."""
        # Hard to detect automatically, look for mixed concerns
        if "fetch" in content and ("render" in content or "display" in content):
            return {
                "term_id": term.term_id,
                "term_title": term.title,
                "severity": "medium",
                "message": "Potential separation of concerns violation: mixing data fetching with UI rendering",
            }
        return None

    def _check_yagni(self, content: str, term: CodexTerm) -> Optional[Dict]:
        """Check for YAGNI violations (unnecessary features)."""
        # Look for commented-out code or future features
        if "# future" in content.lower() or "// future" in content.lower():
            return {
                "term_id": term.term_id,
                "term_title": term.title,
                "severity": "low",
                "message": "Potential YAGNI violation: future feature commented out",
            }
        return None

    def get_all_terms(self) -> Dict[int, CodexTerm]:
        """Get all loaded codex terms."""
        # Reload if needed
        if self.auto_reload_on_change and self.codex_path:
            if self.codex_path.stat().st_mtime > self._last_file_mtime:
                self._load_codex()

        return self._codex_terms.copy()

    def get_manifest(self) -> Dict[str, Any]:
        """Get codex manifest with summary information."""
        return {
            "version": self._version,
            "term_count": len(self._codex_terms),
            "categories": {
                category: len(term_ids)
                for category, term_ids in self._categories.items()
            },
            "last_loaded": self._last_loaded.isoformat() if self._last_loaded else None,
        }

    def clear_cache(self) -> None:
        """Clear the LRU cache and reset internal state."""
        # Clear the LRU cache for load_codex_terms (if it exists)
        if hasattr(self, 'load_codex_terms') and hasattr(self.load_codex_terms, 'cache_clear'):
            self.load_codex_terms.cache_clear()
        # Reset internal state
        self._codex_terms.clear()
        self._categories.clear()
        # Note: _loaded_terms doesn't exist in current implementation
        self._cache_hash = None
        self._context_hash = None
        logger.info("Codex cache cleared")


# Singleton instance for global access
_default_loader: Optional[CodexLoader] = None


def get_default_codex_loader() -> CodexLoader:
    """Get or create the default CodexLoader instance."""
    global _default_loader
    if _default_loader is None:
        _default_loader = CodexLoader()
    return _default_loader
