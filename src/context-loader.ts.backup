/**
 * StrRay Context Loader
 *
 * Loads Universal Development Codex v1.2.20 context for agent initialization.
 * Provides structured access to 30+ codex terms, interweaves, lenses, and anti-patterns.
 *
 * @version 1.0.0
 * @since 2026-01-06
 */

import * as fs from "fs";
import * as path from "path";

/**
 * Codex term structure
 */
export interface CodexTerm {
	number: number;
	description: string;
	category: "core" | "extended" | "architecture" | "advanced";
	zeroTolerance?: boolean;
	enforcementLevel?: "low" | "medium" | "high" | "blocking";
}

/**
 * Parsed codex context
 */
export interface CodexContext {
	version: string;
	lastUpdated: string;
	terms: Map<number, CodexTerm>;
	interweaves: string[];
	lenses: string[];
	principles: string[];
	antiPatterns: string[];
	validationCriteria: Record<string, boolean>;
	frameworkAlignment: Record<string, string>;
	errorPreventionTarget: number;
}

/**
 * Context loading result
 */
export interface ContextLoadResult {
	success: boolean;
	context?: CodexContext;
	error?: string;
	warnings: string[];
}

/**
 * Type guard for regex match results
 */
function isValidMatch(match: RegExpMatchArray | null, index: number): match is RegExpMatchArray & { [K in keyof RegExpMatchArray]: K extends typeof index ? string : RegExpMatchArray[K] } {
	return match !== null && match[index] !== undefined;
}

/**
 * StrRay Context Loader
 *
	 * Loads and parses the Universal Development Codex v1.2.20 from codex.json
 */
export class StrRayContextLoader {
	private static instance: StrRayContextLoader;
	private cachedContext: CodexContext | null = null;
	private codexFilePaths: string[] = [];

	private constructor() {
		this.codexFilePaths = [".strray/codex.json", "codex.json"];
	}

	/**
	 * Get singleton instance
	 */
	public static getInstance(): StrRayContextLoader {
		if (!StrRayContextLoader.instance) {
			StrRayContextLoader.instance = new StrRayContextLoader();
		}
		return StrRayContextLoader.instance;
	}

	/**
	 * Load codex context
	 *
	 * Attempts to load the Universal Development Codex from multiple possible locations.
	 * Returns cached context if available and not expired.
	 */
	public async loadCodexContext(projectRoot: string): Promise<ContextLoadResult> {
		const warnings: string[] = [];

		// Validate project root
		if (!projectRoot || projectRoot.trim() === '') {
			return {
				success: false,
				error: 'Invalid project root path: path cannot be empty',
				warnings,
			};
		}

		if (this.cachedContext) {
			return {
				success: true,
				context: this.cachedContext,
				warnings,
			};
		}

		for (const relativePath of this.codexFilePaths) {
			const fullPath = path.join(projectRoot, relativePath);

			if (fs.existsSync(fullPath)) {
				try {
					const content = fs.readFileSync(fullPath, "utf-8");
					const context = this.parseCodexContent(content, fullPath);
					this.cachedContext = context;
					return {
						success: true,
						context,
						warnings,
					};
				} catch (error) {
					const msg = `Failed to parse ${fullPath}: ${error instanceof Error ? error.message : String(error)}`;
					warnings.push(msg);
				}
			}
		}

		return {
			success: false,
			error: "No valid codex file found. Checked: " + this.codexFilePaths.join(", "),
			warnings,
		};
	}

	/**
	 * Parse codex content from markdown
	 *
	 * Extracts all 30+ codex terms, interweaves, lenses, and principles from markdown.
	 */
	private parseCodexContent(content: string, sourcePath: string): CodexContext {
		// Validate inputs
		if (!content || content.trim() === '') {
			throw new Error('Invalid content provided: content cannot be empty');
	}

		try {
			// Parse JSON content
			const jsonData = JSON.parse(content);

			// Convert terms object to Map
			const termsMap = new Map<number, CodexTerm>();
			if (jsonData.terms) {
				Object.entries(jsonData.terms).forEach(([key, term]: [string, any]) => {
					termsMap.set(parseInt(key, 10), term);
				});
			}

			// Build context from JSON data
			const context: CodexContext = {
				version: jsonData.version || "1.2.20",
				lastUpdated: jsonData.lastUpdated || new Date().toISOString(),
				terms: termsMap,
				interweaves: jsonData.interweaves || [],
				lenses: jsonData.lenses || [],
				principles: jsonData.principles || [],
				antiPatterns: jsonData.antiPatterns || [],
				validationCriteria: jsonData.validationCriteria || {},
				frameworkAlignment: jsonData.frameworkAlignment || {},
				errorPreventionTarget: jsonData.errorPreventionTarget || 0.996,
			};

			return context;
		} catch (error) {
			throw new Error(`Failed to parse codex JSON from ${sourcePath}: ${error instanceof Error ? error.message : String(error)}`);
		}
	}
			terms: new Map(),
			interweaves: [],
			lenses: [],
			principles: [],
			antiPatterns: [],
			validationCriteria: {},
			frameworkAlignment: {},
			errorPreventionTarget: 0.996,
		};

		const lines = content.split("\n");
		let currentSection: string | null = null;

		// Debug: show first few lines
		console.log(`DEBUG: First 5 lines:`, lines.slice(0, 5).map((l, i) => `${i}: '${l}'`));

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i]?.trim() || "";
			// Debug: check each line
			if (line.includes('####')) {
				console.log(`DEBUG: Line ${i} contains ####: '${line}'`);
			}

			if (line.startsWith("###") || line.startsWith("##")) {
				currentSection = line.replace(/#+\s*/, "").toLowerCase();
				continue;
			}

			// Parse metadata lines
			if (line.includes('**Version**: ')) {
				const versionMatch = line.match(/(\d+\.\d+\.\d+)/);
				if (versionMatch && versionMatch[1]) {
					Object.assign(context, { version: versionMatch[1] });
					continue;
				}
			}

			if (line.includes('95.5%')) {
				context.errorPreventionTarget = 0.955;
				continue;
			}

			// Parse term headers
			if (line.startsWith("#### ")) {
				// Debug: check if term parsing is reached
				console.log(`DEBUG: Found term header: ${line}`);
				const afterHash = line.substring(4).trim();
				const dotIndex = afterHash.indexOf(".");
				if (dotIndex > 0) {
					const numStr = afterHash.substring(0, dotIndex).trim();
					const termNum = parseInt(numStr, 10);
					if (!isNaN(termNum)) {
						const termName = afterHash.substring(dotIndex + 1).trim();

						// Collect description lines until next header
						const descriptionLines: string[] = [];
						for (let j = i + 1; j < lines.length; j++) {
							const descLine = lines[j]?.trim() || "";
							if (descLine.startsWith("#### ") || descLine.startsWith("###") || descLine.startsWith("##") || descLine === "") {
								break;
							}
							if (descLine && !descLine.startsWith("```")) {
								descriptionLines.push(descLine);
							}
						}

						const description = descriptionLines.join(" ").trim();
						if (description) {
							const term: CodexTerm = {
								number: termNum,
								description,
								category: this.inferTermCategory(termNum, termName),
								zeroTolerance: /zero.tolerance|blocking/i.test(line),
								enforcementLevel: /blocking/i.test(line) ? "blocking" :
									/high/i.test(line) ? "high" :
									/medium/i.test(line) ? "medium" : "low"
							};

							context.terms.set(termNum, term);
						}
					}
				}
			}

			if (line.toLowerCase().includes("interweave") && line.startsWith("##")) {
				context.interweaves.push(line.replace(/^#+\s*/, ""));
			}

			if (line.toLowerCase().includes("lens") && line.startsWith("##")) {
				context.lenses.push(line.replace(/^#+\s*/, ""));
			}

			if (line.toLowerCase().includes("principle") && !line.toLowerCase().includes("anti")) {
				context.principles.push(line);
			}

			if (line.toLowerCase().includes("anti-pattern")) {
				context.antiPatterns.push(line);
			}

			const checkboxMatch = line.match(/^\s*-\s*\[\s*\]\s*(.+)$/);
			if (checkboxMatch && checkboxMatch[1]) {
				context.validationCriteria[checkboxMatch[1].trim()] = false;
			}
		}

		// Fill in missing core terms if not found in content
		for (let i = 1; i <= 10; i++) {
			if (!context.terms.has(i)) {
				context.terms.set(i, {
					number: i,
					description: `Core Term ${i} - Not found in ${sourcePath}`,
					category: "core",
				});
			}
		}

		context.frameworkAlignment = {
			"oh-my-opencode": "v2.12.0",
			"StrRay Framework": "v1.0.0",
			"Codex Version": context.version,
		};

		return context;
	}

	/**
	 * Infer term category based on number and content
	 */
	private inferTermCategory(termNumber: number, termName: string): CodexTerm["category"] {
		if (termNumber <= 10) {
			return "core";
		} else if (termNumber <= 20) {
			return "extended";
		} else if (termNumber <= 30) {
			return "architecture";
		} else {
			return "advanced";
		}
	}

	/**
	 * Get specific codex term by number
	 */
	public getTerm(context: CodexContext, termNumber: number): CodexTerm | undefined {
		return context.terms.get(termNumber);
	}

	/**
	 * Get all core terms (1-10)
	 */
	public getCoreTerms(context: CodexContext): CodexTerm[] {
		return Array.from(context.terms.values())
			.filter((term) => term.category === "core")
			.sort((a, b) => a.number - b.number);
	}

	/**
	 * Get zero-tolerance terms that require immediate blocking
	 */
	public getZeroToleranceTerms(context: CodexContext): CodexTerm[] {
		return Array.from(context.terms.values())
			.filter((term) => term.zeroTolerance || term.enforcementLevel === "blocking")
			.sort((a, b) => a.number - b.number);
	}

	/**
	 * Validate action against codex
	 *
	 * Checks if an action complies with relevant codex terms.
	 * Returns validation result with violations and recommendations.
	 */
	public validateAgainstCodex(
		context: CodexContext,
		action: string,
		actionDetails: Record<string, unknown>,
	): {
		compliant: boolean;
		violations: Array<{
			term: CodexTerm;
			reason: string;
			severity: "low" | "medium" | "high" | "blocking";
		}>;
		recommendations: string[];
	} {
		const violations: Array<{
			term: CodexTerm;
			reason: string;
			severity: "low" | "medium" | "high" | "blocking";
		}> = [];
		const recommendations: string[] = [];

		if (actionDetails.includesAny) {
			const dangerousPatterns = ["any", "@ts-ignore", "@ts-expect-error"];
			if (dangerousPatterns.some((pattern) => action.includes(pattern))) {
				const term11 = context.terms.get(11);
				if (term11) {
					violations.push({
						term: term11,
						reason: 'Type safety violation detected - using "any" or type suppression',
						severity: "high",
					});
				}
			}
		}

		if (action.includes("TODO") || action.includes("FIXME") || action.includes("XXX")) {
			const term7 = context.terms.get(7);
			if (term7) {
				violations.push({
					term: term7,
					reason: "Unresolved tasks detected - violates Resolve All Errors principle",
					severity: "blocking",
				});
			}
		}

		if (actionDetails.isOverEngineered) {
			const term3 = context.terms.get(3);
			if (term3) {
				violations.push({
					term: term3,
					reason: "Solution appears over-engineered - violates simplicity principle",
					severity: "medium",
				});
				recommendations.push("Simplify the solution by removing unnecessary abstractions");
			}
		}

		if (action.includes("while(true)") || action.includes("for(;;)")) {
			const term8 = context.terms.get(8);
			if (term8) {
				violations.push({
					term: term8,
					reason: "Potential infinite loop detected",
					severity: "blocking",
				});
				recommendations.push("Add clear termination conditions to the loop");
			}
		}

		return {
			compliant: violations.filter((v) => v.severity === "blocking").length === 0,
			violations,
			recommendations,
		};
	}

	/**
	 * Clear cached context (useful for testing or forced reload)
	 */
	public clearCache(): void {
		this.cachedContext = null;
	}

	/**
	 * Check if context is loaded and valid
	 */
	public isContextLoaded(): boolean {
		return this.cachedContext !== null;
	}

	/**
	 * Get context statistics
	 */
	public getContextStats(): {
		loaded: boolean;
		termCount: number;
		categoryBreakdown: Record<string, number>;
		zeroToleranceCount: number;
	} {
		if (!this.cachedContext) {
			return {
				loaded: false,
				termCount: 0,
				categoryBreakdown: {},
				zeroToleranceCount: 0,
			};
		}

		const context = this.cachedContext!;
		const terms = Array.from(context.terms.values());
		const categoryBreakdown: Record<string, number> = {};

		terms.forEach((term) => {
			categoryBreakdown[term.category] = (categoryBreakdown[term.category] || 0) + 1;
		});

		return {
			loaded: true,
			termCount: context.terms.size,
			categoryBreakdown,
			zeroToleranceCount: this.getZeroToleranceTerms(context).length,
		};
	}
}

/**
 * Export singleton instance
 */
export const strRayContextLoader = StrRayContextLoader.getInstance();
