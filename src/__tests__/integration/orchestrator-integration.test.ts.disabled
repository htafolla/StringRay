/**
 * StringRay Framework v1.0.0 - Comprehensive Orchestrator Integration Tests
 *
 * Enterprise-grade integration testing for orchestrator and agent coordination functionality.
 * Validates framework components work together correctly in production scenarios.
 *
 * @version 1.0.0
 * @since 2026-01-08
 */

import { describe, it, expect, beforeEach, afterEach, vi, beforeAll, afterAll } from 'vitest';
import { StringRayOrchestrator, TaskDefinition, TaskResult } from '../../orchestrator.js';
import { SessionStateManager, createSessionStateManager } from '../../session/session-state-manager.js';
import { StringRayStateManager } from '../../state/state-manager.js';
import { SessionCoordinator, createSessionCoordinator } from '../../delegation/session-coordinator.js';
import { ComplexityAnalyzer, complexityAnalyzer } from '../../delegation/complexity-analyzer.js';
import { AgentDelegator, createAgentDelegator } from '../../delegation/agent-delegator.js';
import { PluginRegistry, pluginRegistry, PluginSandbox, pluginSandbox } from '../../plugins/plugin-system.js';
import { PerformanceTestUtils, AsyncTestUtils, MemoryTestUtils, MockFileSystem, MockCodexGenerator } from '../utils/test-helpers.js';

// Mock external dependencies
vi.mock('fs', () => ({
  existsSync: vi.fn(),
  readFileSync: vi.fn(),
  writeFileSync: vi.fn(),
  mkdirSync: vi.fn(),
  rmSync: vi.fn(),
}));

vi.mock('path', () => ({
  join: vi.fn(),
  resolve: vi.fn(),
  basename: vi.fn(),
  dirname: vi.fn(),
}));

describe('StringRay Framework - Comprehensive Orchestrator Integration Tests', () => {
  let orchestrator: StringRayOrchestrator;
  let stateManager: StringRayStateManager;
  let sessionCoordinator: SessionCoordinator;
  let sessionStateManager: SessionStateManager;
  let agentDelegator: AgentDelegator;
  let pluginRegistryInstance: PluginRegistry;
  let mockFs: MockFileSystem;

  // Test data
  const testSessionId = 'test-session-123';
  const testTasks: TaskDefinition[] = [
    {
      id: 'task-1',
      description: 'Initialize framework components',
      subagentType: 'architect',
      priority: 'high'
    },
    {
      id: 'task-2',
      description: 'Load codex context',
      subagentType: 'librarian',
      priority: 'high',
      dependencies: ['task-1']
    },
    {
      id: 'task-3',
      description: 'Validate code compliance',
      subagentType: 'enforcer',
      priority: 'medium',
      dependencies: ['task-2']
    },
    {
      id: 'task-4',
      description: 'Generate test coverage',
      subagentType: 'architect',
      priority: 'low',
      dependencies: ['task-3']
    }
  ];

  beforeAll(() => {
    // Setup global test environment
    vi.useFakeTimers();
    mockFs = new MockFileSystem();
  });

  afterAll(() => {
    vi.useRealTimers();
  });

  beforeEach(() => {
    // Initialize core components
    stateManager = new StringRayStateManager();
    sessionCoordinator = createSessionCoordinator(stateManager);
    sessionStateManager = createSessionStateManager(stateManager, sessionCoordinator);
    agentDelegator = createAgentDelegator(stateManager);
    pluginRegistryInstance = new PluginRegistry();

    // Initialize orchestrator with custom config for testing
    orchestrator = new StringRayOrchestrator({
      maxConcurrentTasks: 3,
      taskTimeout: 10000,
      conflictResolutionStrategy: 'majority_vote'
    } as any);

    // Setup mock codex data
    const mockCodex = MockCodexGenerator.createCompleteCodex();
    mockFs.addFile('/test/project/.strray/codex.json', mockCodex);
    mockFs.addFile('/test/project/codex.json', mockCodex);
  });

  afterEach(() => {
    // Cleanup
    vi.clearAllMocks();
    stateManager.clear();
    
    pluginRegistryInstance = new PluginRegistry(); // Reset registry
  });

  describe('Core Integration Scenarios', () => {
    describe('Orchestrator Initialization', () => {
      it('should successfully initialize orchestrator with all dependencies', async () => {
        expect(orchestrator).toBeDefined();
        expect(orchestrator.getStatus()).toEqual({
          activeTasks: 0,
          config: expect.objectContaining({
            maxConcurrentTasks: 3,
            taskTimeout: 10000,
            conflictResolutionStrategy: 'majority_vote'
          })
        });
      });

      it('should initialize with session coordinator integration', async () => {
        const session = sessionCoordinator.initializeSession(testSessionId);
        expect(session).toBeDefined();
        expect(session.sessionId).toBe(testSessionId);

        // Verify orchestrator can access session
        const sessionStatus = sessionCoordinator.getSessionStatus(testSessionId);
        expect(sessionStatus).toBeDefined();
        expect(sessionStatus?.active).toBe(true);
      });

      it('should initialize with plugin system integration', async () => {
        const plugins = pluginRegistryInstance.listPlugins();
        expect(Array.isArray(plugins)).toBe(true);

        // Verify sandbox is available
        expect(pluginSandbox).toBeDefined();
      });

      it('should handle initialization failures gracefully', async () => {
        // Simulate state manager failure
        const failingStateManager = {
          get: vi.fn().mockImplementation(() => { throw new Error('State manager error'); }),
          set: vi.fn().mockImplementation(() => { throw new Error('State manager error'); }),
          clear: vi.fn()
        } as any;

        const failingCoordinator = createSessionCoordinator(failingStateManager);

        // Orchestrator should still initialize even with dependency issues
        expect(orchestrator).toBeDefined();

        // But operations requiring the failing dependency should handle errors
        await expect(failingCoordinator.initializeSession('failing-session')).rejects.toThrow();
      });
    });

    describe('Agent Coordination', () => {
      it('should coordinate multi-agent task execution with dependencies', async () => {
        const results = await orchestrator.executeComplexTask(
          'Framework initialization workflow',
          testTasks,
          testSessionId
        );

        expect(results).toHaveLength(4);
        expect(results.every(r => r.success)).toBe(true);

        // Verify dependency order was respected
        const taskOrder = results.map(r => r.result.id);
        expect(taskOrder.indexOf('task-1')).toBeLessThan(taskOrder.indexOf('task-2'));
        expect(taskOrder.indexOf('task-2')).toBeLessThan(taskOrder.indexOf('task-3'));
        expect(taskOrder.indexOf('task-3')).toBeLessThan(taskOrder.indexOf('task-4'));
      });

      it('should handle agent delegation with complexity analysis', async () => {
        const complexTask: TaskDefinition = {
          id: 'complex-task',
          description: 'Highly complex multi-step operation requiring expert coordination',
          subagentType: 'architect',
          priority: 'high'
        };

        // Mock complexity analysis
        const complexitySpy = vi.spyOn(complexityAnalyzer, 'analyzeComplexity')
          .mockReturnValue({
            score: 85,
            level: 'high',
            factors: ['multiple_dependencies', 'cross_session_coordination'],
            recommendedAgents: ['architect', 'enforcer']
          });

        const result = await orchestrator.executeComplexTask(
          'Complex coordination test',
          [complexTask],
          testSessionId
        );

        expect(result).toHaveLength(1);
        expect(result[0].success).toBe(true);
        expect(complexitySpy).toHaveBeenCalled();
      });

      it('should resolve conflicts between agent responses', async () => {
        const conflicts = [
          { response: { decision: 'option_a' }, expertiseScore: 80 },
          { response: { decision: 'option_b' }, expertiseScore: 90 },
          { response: { decision: 'option_a' }, expertiseScore: 85 }
        ];

        const resolution = orchestrator.resolveConflicts(conflicts);
        expect(resolution).toBeDefined();

        // With majority_vote strategy, should pick option_a (appears twice)
        expect(resolution.response.decision).toBe('option_a');
      });

      it('should handle agent delegation failures with fallback', async () => {
        // Mock delegation failure for primary agent
        const delegatorSpy = vi.spyOn(agentDelegator, 'delegateTask')
          .mockRejectedValueOnce(new Error('Primary agent unavailable'))
          .mockResolvedValueOnce({ success: true, result: 'Fallback agent response' });

        const task: TaskDefinition = {
          id: 'fallback-test',
          description: 'Test fallback delegation',
          subagentType: 'librarian'
        };

        const result = await orchestrator.executeComplexTask(
          'Fallback test',
          [task],
          testSessionId
        );

        expect(result).toHaveLength(1);
        expect(result[0].success).toBe(true);
      });
    });

    describe('Session Management', () => {
      it('should manage session lifecycle with state persistence', async () => {
        // Create session
        const session = sessionCoordinator.initializeSession(testSessionId);
        expect(session).toBeDefined();

        // Execute tasks in session
        await orchestrator.executeComplexTask('Session test', testTasks, testSessionId);

        // Verify session state
        const sessionStatus = sessionCoordinator.getSessionStatus(testSessionId);
        expect(sessionStatus?.active).toBe(true);
        expect(sessionStatus?.agentCount).toBeGreaterThan(0);

        // Share state between sessions
        const session2 = sessionCoordinator.initializeSession('session-456');
        const shared = sessionStateManager.shareState(testSessionId, 'session-456', 'test-data', { key: 'value' });
        expect(shared).toBe(true);

        // Verify state sharing
        const retrieved = sessionStateManager.getGroupState('session-456', 'test-data');
        expect(retrieved).toEqual({ key: 'value' });
      });

      it('should handle session dependencies and coordination', async () => {
        // Create dependent sessions
        sessionStateManager.registerDependency('session-456', [testSessionId], { type: 'coordination' });

        const chain = sessionStateManager.getDependencyChain('session-456');
        expect(chain.dependencies).toContain(testSessionId);
        expect(chain.canStart).toBe(false); // Depends on testSessionId

        // Complete dependency
        sessionStateManager.updateDependencyState(testSessionId, 'completed');

        const updatedChain = sessionStateManager.getDependencyChain('session-456');
        expect(updatedChain.canStart).toBe(true);
      });

      it('should manage session groups for complex workflows', async () => {
        const group = sessionStateManager.createSessionGroup(
          'test-group',
          [testSessionId, 'session-456', 'session-789'],
          testSessionId
        );

        expect(group.groupId).toBe('test-group');
        expect(group.sessionIds).toHaveLength(3);
        expect(group.coordinatorSession).toBe(testSessionId);

        // Share group state
        const shared = sessionStateManager.shareGroupState(
          'test-group',
          'workflow-data',
          { step: 1, status: 'in_progress' },
          testSessionId
        );

        expect(shared).toBe(true);

        // Verify group state
        const retrieved = sessionStateManager.getGroupState('test-group', 'workflow-data');
        expect(retrieved).toEqual({ step: 1, status: 'in_progress' });
      });

      it('should handle session migration and failover', async () => {
        // Configure failover
        sessionStateManager.configureFailover(
          testSessionId,
          ['backup-1', 'backup-2'],
          5000,
          true
        );

        // Create migration plan
        const plan = sessionStateManager.planMigration(testSessionId, 'backup-1');
        expect(plan.sessionId).toBe(testSessionId);
        expect(plan.targetCoordinator).toBe('backup-1');
        expect(plan.migrationSteps).toHaveLength(6); // validate, transfer, cleanup
        expect(plan.rollbackSteps).toHaveLength(3); // restore steps

        // Execute migration (mock successful)
        const migrationSpy = vi.spyOn(sessionStateManager, 'executeMigration')
          .mockResolvedValue(true);

        const success = await sessionStateManager.executeMigration(plan);
        expect(success).toBe(true);
        expect(migrationSpy).toHaveBeenCalledWith(plan);
      });
    });

    describe('Plugin System', () => {
      it('should load and execute plugins securely', async () => {
        // Create mock plugin
        const mockPluginCode = `
          class MockPlugin {
            constructor() {
              this.metadata = {
                id: 'test-plugin',
                name: 'Test Plugin',
                version: '1.0.0',
                description: 'Test plugin for integration testing',
                author: 'Test Author',
                license: 'MIT',
                engines: { strray: '^1.0.0', node: '^18.0.0' },
                strrayCapabilities: {
                  agentTypes: ['test-agent'],
                  supportedTasks: ['test-task'],
                  requiredPermissions: ['read'],
                  providedServices: ['test-service']
                }
              };
            }

            async initialize(config) {
              this.config = config;
              return true;
            }

            async activate() {
              this.active = true;
              return true;
            }

            async createAgent(type, config) {
              return {
                id: 'test-agent-1',
                type,
                async executeTask(task) {
                  return { success: true, result: 'Plugin executed: ' + task.description };
                }
              };
            }

            async getHealthStatus() {
              return {
                status: 'healthy',
                lastCheck: Date.now(),
                uptime: 1000,
                errorCount: 0,
                warningCount: 0,
                details: {}
              };
            }
          }

          module.exports = { createPlugin: () => new MockPlugin() };
        `;

        mockFs.addFile('/test/plugins/test-plugin/index.js', mockPluginCode);
        mockFs.addFile('/test/plugins/test-plugin/package.json', JSON.stringify({
          name: 'test-plugin',
          version: '1.0.0',
          main: 'index.js',
          strrayCapabilities: {
            agentTypes: ['test-agent'],
            supportedTasks: ['test-task'],
            requiredPermissions: ['read']
          }
        }));

        // Register plugin
        const registration = await pluginRegistryInstance.registerPlugin('/test/plugins/test-plugin');
        expect(registration.success).toBe(true);

        // Activate plugin
        const activation = await pluginRegistryInstance.activatePlugin('test-plugin', { test: true });
        expect(activation).toBe(true);

        // Verify plugin is active
        const plugins = pluginRegistryInstance.listPlugins();
        const testPlugin = plugins.find(p => p.id === 'test-plugin');
        expect(testPlugin).toBeDefined();
        expect(testPlugin?.active).toBe(true);

        // Get plugin health
        const health = await pluginRegistryInstance.getPluginHealth('test-plugin');
        expect(health?.status).toBe('healthy');
      });

      it('should enforce plugin security sandboxing', async () => {
        // Test sandbox restrictions
        const sandbox = new PluginSandbox({
          memoryLimit: 10, // 10MB limit
          timeout: 5000, // 5 second timeout
          allowedModules: ['util'], // Limited modules
          networkAccess: false,
          fileSystemAccess: false
        });

        expect(sandbox).toBeDefined();

        // Attempt to execute plugin with restricted operations should fail
        const dangerousPlugin = `
          const fs = require('fs');
          module.exports = {
            createPlugin: () => ({
              async dangerousOperation() {
                fs.writeFileSync('/dangerous/path', 'data'); // Should be blocked
                return 'success';
              }
            })
          };
        `;

        mockFs.addFile('/test/plugins/dangerous-plugin/index.js', dangerousPlugin);

        // Plugin validation should catch security issues
        const validation = await pluginRegistryInstance.registerPlugin('/test/plugins/dangerous-plugin');
        expect(validation.success).toBe(false);
        expect(validation.errors).toContain('Plugin registration failed');
      });

      it('should handle plugin lifecycle management', async () => {
        // Create and register a simple plugin
        const simplePlugin = `
          module.exports = {
            createPlugin: () => ({
              metadata: {
                id: 'lifecycle-test',
                name: 'Lifecycle Test',
                version: '1.0.0',
                description: 'Test plugin lifecycle',
                author: 'Test',
                license: 'MIT',
                engines: { strray: '^1.0.0', node: '^18.0.0' },
                strrayCapabilities: {
                  agentTypes: ['test'],
                  supportedTasks: ['lifecycle'],
                  requiredPermissions: []
                }
              },
              async initialize() { this.initialized = true; },
              async activate() { this.active = true; },
              async deactivate() { this.active = false; },
              async dispose() { this.disposed = true; },
              async getHealthStatus() {
                return { status: 'healthy', lastCheck: Date.now(), uptime: 0, errorCount: 0, warningCount: 0, details: {} };
              }
            })
          };
        `;

        mockFs.addFile('/test/plugins/lifecycle-plugin/index.js', simplePlugin);
        mockFs.addFile('/test/plugins/lifecycle-plugin/package.json', JSON.stringify({
          name: 'lifecycle-plugin',
          version: '1.0.0',
          main: 'index.js',
          strrayCapabilities: { agentTypes: ['test'], supportedTasks: ['lifecycle'] }
        }));

        // Register and activate
        await pluginRegistryInstance.registerPlugin('/test/plugins/lifecycle-plugin');
        await pluginRegistryInstance.activatePlugin('lifecycle-test');

        // Verify active
        let plugins = pluginRegistryInstance.listPlugins();
        expect(plugins.find(p => p.id === 'lifecycle-test')?.active).toBe(true);

        // Deactivate
        await pluginRegistryInstance.deactivatePlugin('lifecycle-test');
        plugins = pluginRegistryInstance.listPlugins();
        expect(plugins.find(p => p.id === 'lifecycle-test')?.active).toBe(false);

        // Unregister
        const unregistered = await pluginRegistryInstance.unregisterPlugin('lifecycle-test');
        expect(unregistered).toBe(true);

        plugins = pluginRegistryInstance.listPlugins();
        expect(plugins.find(p => p.id === 'lifecycle-test')).toBeUndefined();
      });
    });

    describe('Performance Integration', () => {
      it('should maintain performance under concurrent load', async () => {
        const concurrentTasks = 10;
        const tasks: TaskDefinition[] = Array.from({ length: concurrentTasks }, (_, i) => ({
          id: `perf-task-${i}`,
          description: `Performance test task ${i}`,
          subagentType: 'architect',
          priority: i % 2 === 0 ? 'high' : 'medium'
        }));

        const { result: results, duration } = PerformanceTestUtils.measureExecutionTime(
          () => orchestrator.executeComplexTask('Performance test', tasks, testSessionId)
        );

        await results;

        // Should complete within reasonable time (adjust based on test environment)
        expect(duration).toBeLessThan(5000); // 5 seconds for 10 concurrent tasks
      });

      it('should handle memory efficiently during large operations', async () => {
        const largeTaskSet: TaskDefinition[] = Array.from({ length: 50 }, (_, i) => ({
          id: `large-task-${i}`,
          description: `Large scale task ${i} with substantial processing requirements`,
          subagentType: 'librarian',
          priority: 'medium'
        }));

        const { result: memoryUsage, memoryDelta } = MemoryTestUtils.monitorMemoryUsage(
          () => orchestrator.executeComplexTask('Large scale test', largeTaskSet, testSessionId)
        );

        await memoryUsage;

        // Memory usage should be reasonable (less than 50MB increase)
        expect(memoryDelta).toBeLessThan(50 * 1024 * 1024); // 50MB
      });

      it('should enforce performance budgets', async () => {
        // Test with performance monitoring
        const startTime = Date.now();

        // Execute multiple complex operations
        const operations = Array.from({ length: 5 }, (_, i) =>
          orchestrator.executeComplexTask(`Budget test ${i}`, testTasks.slice(0, 2), `session-${i}`)
        );

        await Promise.all(operations);
        const endTime = Date.now();

        const totalDuration = endTime - startTime;
        const avgDuration = totalDuration / 5;

        // Performance budget: each operation should complete within 2 seconds
        PerformanceTestUtils.assertPerformance(avgDuration, 2000, 'Average complex task execution');
      });

      it('should handle timeout scenarios gracefully', async () => {
        // Create orchestrator with very short timeout
        const fastOrchestrator = new StringRayOrchestrator({
          maxConcurrentTasks: 1,
          taskTimeout: 100, // 100ms timeout
          conflictResolutionStrategy: 'majority_vote'
        });

        const slowTask: TaskDefinition = {
          id: 'slow-task',
          description: 'Task that takes longer than timeout',
          subagentType: 'architect'
        };

        // Mock slow execution
        const originalDelegate = fastOrchestrator['delegateToSubagent'];
        fastOrchestrator['delegateToSubagent'] = vi.fn().mockImplementation(
          () => AsyncTestUtils.delay(200) // 200ms delay > 100ms timeout
        );

        const results = await fastOrchestrator.executeComplexTask(
          'Timeout test',
          [slowTask],
          testSessionId
        );

        expect(results).toHaveLength(1);
        expect(results[0].success).toBe(false);
        expect(results[0].error).toContain('timeout');

        // Restore original method
        fastOrchestrator['delegateToSubagent'] = originalDelegate;
      });
    });
  });

  describe('Error Handling Tests', () => {
    it('should handle orchestrator task execution failures', async () => {
      // Mock task failure
      const originalDelegate = orchestrator['delegateToSubagent'];
      orchestrator['delegateToSubagent'] = vi.fn().mockRejectedValue(new Error('Task execution failed'));

      const results = await orchestrator.executeComplexTask('Failure test', testTasks, testSessionId);

      expect(results.some(r => !r.success)).toBe(true);
      expect(results.some(r => r.error?.includes('Task execution failed'))).toBe(true);

      // Orchestrator should continue with other tasks
      expect(results.length).toBe(4);

      // Restore
      orchestrator['delegateToSubagent'] = originalDelegate;
    });

    it('should handle circular dependencies', async () => {
      const circularTasks: TaskDefinition[] = [
        { id: 'a', description: 'Task A', subagentType: 'architect', dependencies: ['b'] },
        { id: 'b', description: 'Task B', subagentType: 'librarian', dependencies: ['a'] }
      ];

      await expect(
        orchestrator.executeComplexTask('Circular dependency test', circularTasks, testSessionId)
      ).rejects.toThrow('Circular dependency detected');
    });

    it('should handle session state corruption', async () => {
      // Corrupt session state
      stateManager.set('session:corrupted', undefined);
      (stateManager as any).store.set('session:corrupted', null);

      // Operations should continue despite corruption
      const session = sessionCoordinator.initializeSession('corrupted-session');
      expect(session).toBeDefined();

      // State manager should handle corruption gracefully
      const corruptedValue = stateManager.get('session:corrupted');
      expect(corruptedValue).toBeUndefined();
    });

    it('should recover from plugin execution failures', async () => {
      // Register a failing plugin
      const failingPlugin = `
        module.exports = {
          createPlugin: () => ({
            metadata: {
              id: 'failing-plugin',
              name: 'Failing Plugin',
              version: '1.0.0',
              description: 'Plugin that fails',
              author: 'Test',
              license: 'MIT',
              engines: { strray: '^1.0.0', node: '^18.0.0' },
              strrayCapabilities: { agentTypes: ['fail'], supportedTasks: ['fail'] }
            },
            async initialize() { throw new Error('Plugin initialization failed'); }
          })
        };
      `;

      mockFs.addFile('/test/plugins/failing-plugin/index.js', failingPlugin);
      mockFs.addFile('/test/plugins/failing-plugin/package.json', JSON.stringify({
        name: 'failing-plugin',
        strrayCapabilities: { agentTypes: ['fail'], supportedTasks: ['fail'] }
      }));

      const registration = await pluginRegistryInstance.registerPlugin('/test/plugins/failing-plugin');
      expect(registration.success).toBe(false);

      // Registry should remain functional
      const plugins = pluginRegistryInstance.listPlugins();
      expect(Array.isArray(plugins)).toBe(true);
    });
  });

  describe('Concurrency Tests', () => {
    it('should handle multiple concurrent sessions', async () => {
      const sessionCount = 5;
      const sessions = Array.from({ length: sessionCount }, (_, i) =>
        `concurrent-session-${i}`
      );

      // Create multiple sessions concurrently
      const sessionPromises = sessions.map(sessionId =>
        sessionCoordinator.initializeSession(sessionId)
      );

      const createdSessions = await Promise.all(sessionPromises);
      expect(createdSessions).toHaveLength(sessionCount);
      createdSessions.forEach(session => expect(session).toBeDefined());

      // Execute tasks in all sessions concurrently
      const taskPromises = sessions.map(sessionId =>
        orchestrator.executeComplexTask(`Concurrent tasks for ${sessionId}`, testTasks, sessionId)
      );

      const results = await Promise.all(taskPromises);
      expect(results).toHaveLength(sessionCount);
      results.forEach(sessionResults => {
        expect(sessionResults).toHaveLength(4);
        expect(sessionResults.every(r => r.success)).toBe(true);
      });
    });

    it('should manage resource contention', async () => {
      // Create high contention scenario
      const highLoadTasks: TaskDefinition[] = Array.from({ length: 20 }, (_, i) => ({
        id: `high-load-${i}`,
        description: `High load task ${i}`,
        subagentType: 'architect',
        priority: 'high'
      }));

      const results = await orchestrator.executeComplexTask(
        'High contention test',
        highLoadTasks,
        testSessionId
      );

      expect(results).toHaveLength(20);
      // Should respect maxConcurrentTasks limit (3)
      expect(results.filter(r => r.duration < 1000).length).toBeLessThanOrEqual(3);
    });

    it('should handle session state sharing under concurrency', async () => {
      const session1 = 'concurrency-session-1';
      const session2 = 'concurrency-session-2';

      sessionCoordinator.createSession(session1);
      sessionCoordinator.createSession(session2);

      // Concurrent state sharing operations
      const sharePromises = Array.from({ length: 10 }, (_, i) =>
        sessionStateManager.shareState(session1, session2, `concurrent-key-${i}`, `value-${i}`)
      );

      const shareResults = await Promise.all(sharePromises);
      expect(shareResults.every(r => r === true)).toBe(true);

      // Verify all state was shared
      for (let i = 0; i < 10; i++) {
        const value = sessionStateManager.getGroupState(session2, `concurrent-key-${i}`);
        expect(value).toBe(`value-${i}`);
      }
    });
  });

  describe('Boundary Tests', () => {
    it('should handle maximum concurrent tasks limit', async () => {
      const maxTasks: TaskDefinition[] = Array.from({ length: 10 }, (_, i) => ({
        id: `max-task-${i}`,
        description: `Maximum load task ${i}`,
        subagentType: 'librarian'
      }));

      const results = await orchestrator.executeComplexTask(
        'Maximum concurrency test',
        maxTasks,
        testSessionId
      );

      expect(results).toHaveLength(10);
      expect(results.every(r => r.success)).toBe(true);
    });

    it('should handle empty task sets', async () => {
      const results = await orchestrator.executeComplexTask('Empty test', [], testSessionId);
      expect(results).toHaveLength(0);
    });

    it('should handle very large task descriptions', async () => {
      const largeDescription = 'A'.repeat(10000); // 10KB description
      const largeTask: TaskDefinition = {
        id: 'large-desc-task',
        description: largeDescription,
        subagentType: 'architect'
      };

      const results = await orchestrator.executeComplexTask(
        'Large description test',
        [largeTask],
        testSessionId
      );

      expect(results).toHaveLength(1);
      expect(results[0].success).toBe(true);
    });

    it('should handle plugin registry limits', async () => {
      // Create maximum number of plugins
      const pluginPromises = Array.from({ length: 50 }, async (_, i) => {
        const pluginCode = `
          module.exports = {
            createPlugin: () => ({
              metadata: {
                id: 'boundary-plugin-${i}',
                name: 'Boundary Plugin ${i}',
                version: '1.0.0',
                description: 'Boundary test plugin ${i}',
                author: 'Test',
                license: 'MIT',
                engines: { strray: '^1.0.0', node: '^18.0.0' },
                strrayCapabilities: { agentTypes: ['test'], supportedTasks: ['boundary'] }
              },
              async initialize() {},
              async activate() {},
              async getHealthStatus() {
                return { status: 'healthy', lastCheck: Date.now(), uptime: 0, errorCount: 0, warningCount: 0, details: {} };
              }
            })
          };
        `;

        mockFs.addFile(`/test/plugins/boundary-plugin-${i}/index.js`, pluginCode);
        mockFs.addFile(`/test/plugins/boundary-plugin-${i}/package.json`, JSON.stringify({
          name: `boundary-plugin-${i}`,
          strrayCapabilities: { agentTypes: ['test'], supportedTasks: ['boundary'] }
        }));

        return pluginRegistryInstance.registerPlugin(`/test/plugins/boundary-plugin-${i}`);
      });

      const registrations = await Promise.all(pluginPromises);
      const successful = registrations.filter(r => r.success).length;

      // Should handle reasonable number of plugins
      expect(successful).toBeGreaterThan(40);
    });
  });

  describe('Integration Flow Tests', () => {
    it('should execute complete end-to-end framework workflow', async () => {
      // 1. Initialize framework components
      expect(orchestrator).toBeDefined();
      expect(sessionCoordinator).toBeDefined();
      expect(sessionStateManager).toBeDefined();

      // 2. Create session and load plugins
      const session = sessionCoordinator.createSession('e2e-session');
      expect(session.id).toBe('e2e-session');

      // 3. Register and activate plugins
      const mockPlugin = `
        module.exports = {
          createPlugin: () => ({
            metadata: {
              id: 'e2e-plugin',
              name: 'E2E Plugin',
              version: '1.0.0',
              description: 'End-to-end test plugin',
              author: 'Test',
              license: 'MIT',
              engines: { strray: '^1.0.0', node: '^18.0.0' },
              strrayCapabilities: {
                agentTypes: ['e2e-agent'],
                supportedTasks: ['e2e-task'],
                requiredPermissions: ['execute']
              }
            },
            async initialize() { return true; },
            async activate() { return true; },
            async createAgent(type) {
              return {
                id: 'e2e-agent-1',
                type,
                async executeTask(task) {
                  return { success: true, result: \`E2E executed: \${task.description}\` };
                }
              };
            },
            async getHealthStatus() {
              return { status: 'healthy', lastCheck: Date.now(), uptime: 1000, errorCount: 0, warningCount: 0, details: {} };
            }
          })
        };
      `;

      mockFs.addFile('/test/plugins/e2e-plugin/index.js', mockPlugin);
      mockFs.addFile('/test/plugins/e2e-plugin/package.json', JSON.stringify({
        name: 'e2e-plugin',
        strrayCapabilities: { agentTypes: ['e2e-agent'], supportedTasks: ['e2e-task'] }
      }));

      await pluginRegistryInstance.registerPlugin('/test/plugins/e2e-plugin');
      await pluginRegistryInstance.activatePlugin('e2e-plugin');

      // 4. Setup session dependencies
      sessionStateManager.registerDependency('e2e-session', [], { workflow: 'e2e-test' });

      // 5. Execute complex workflow
      const workflowTasks: TaskDefinition[] = [
        {
          id: 'e2e-init',
          description: 'Initialize E2E workflow',
          subagentType: 'architect',
          priority: 'high'
        },
        {
          id: 'e2e-plugin-task',
          description: 'Execute plugin-based task',
          subagentType: 'e2e-agent',
          priority: 'high',
          dependencies: ['e2e-init']
        },
        {
          id: 'e2e-validation',
          description: 'Validate E2E results',
          subagentType: 'enforcer',
          priority: 'medium',
          dependencies: ['e2e-plugin-task']
        }
      ];

      const workflowResults = await orchestrator.executeComplexTask(
        'Complete E2E Framework Workflow',
        workflowTasks,
        'e2e-session'
      );

      // 6. Verify complete workflow success
      expect(workflowResults).toHaveLength(3);
      expect(workflowResults.every(r => r.success)).toBe(true);

      // 7. Verify session state
      const sessionStatus = sessionCoordinator.getSessionStatus('e2e-session');
      expect(sessionStatus?.active).toBe(true);

      // 8. Verify plugin health
      const pluginHealth = await pluginRegistryInstance.getPluginHealth('e2e-plugin');
      expect(pluginHealth?.status).toBe('healthy');

      // 9. Verify state sharing worked
      const sharedState = sessionStateManager.shareState('e2e-session', 'e2e-session', 'workflow-complete', true);
      expect(sharedState).toBe(true);

      console.log('✅ Complete E2E Framework Workflow executed successfully');
    });

    it('should handle complex multi-session coordination workflow', async () => {
      // Create multiple coordinating sessions
      const coordinatorSession = sessionCoordinator.createSession('coordinator');
      const workerSession1 = sessionCoordinator.createSession('worker-1');
      const workerSession2 = sessionCoordinator.createSession('worker-2');

      // Setup session group
      const group = sessionStateManager.createSessionGroup(
        'complex-workflow-group',
        ['coordinator', 'worker-1', 'worker-2'],
        'coordinator'
      );

      // Register dependencies
      sessionStateManager.registerDependency('worker-1', ['coordinator'], { role: 'worker' });
      sessionStateManager.registerDependency('worker-2', ['coordinator'], { role: 'worker' });

      // Execute coordinated workflow
      const coordinatorTasks: TaskDefinition[] = [{
        id: 'coordination-setup',
        description: 'Setup multi-session coordination',
        subagentType: 'architect',
        priority: 'high'
      }];

      const workerTasks: TaskDefinition[] = [{
        id: 'worker-processing',
        description: 'Process work assigned by coordinator',
        subagentType: 'librarian',
        priority: 'medium'
      }];

      // Execute all workflows concurrently
      const workflows = [
        orchestrator.executeComplexTask('Coordinator workflow', coordinatorTasks, 'coordinator'),
        orchestrator.executeComplexTask('Worker 1 workflow', workerTasks, 'worker-1'),
        orchestrator.executeComplexTask('Worker 2 workflow', workerTasks, 'worker-2')
      ];

      const workflowResults = await Promise.all(workflows);

      // Verify all workflows completed
      expect(workflowResults).toHaveLength(3);
      workflowResults.forEach(results => {
        expect(results.every(r => r.success)).toBe(true);
      });

      // Share results across sessions
      sessionStateManager.shareGroupState('complex-workflow-group', 'final-result',
        { status: 'completed', participants: 3 }, 'coordinator');

      // Verify group state
      const finalResult = sessionStateManager.getGroupState('complex-workflow-group', 'final-result');
      expect(finalResult).toEqual({ status: 'completed', participants: 3 });

      console.log('✅ Complex multi-session coordination workflow completed successfully');
    });
  });

  describe('Coverage Goals Validation', () => {
    it('should achieve 90%+ orchestrator functionality coverage', async () => {
      // Test all major orchestrator methods
      const status = orchestrator.getStatus();
      expect(status).toBeDefined();
      expect(typeof status.activeTasks).toBe('number');
      expect(status.config).toBeDefined();

      // Test conflict resolution strategies
      const conflicts = [
        { response: { choice: 'A' }, expertiseScore: 80 },
        { response: { choice: 'B' }, expertiseScore: 90 },
        { response: { choice: 'A' }, expertiseScore: 85 }
      ];

      const majorityResolution = orchestrator.resolveConflicts(conflicts);
      expect(majorityResolution).toBeDefined();

      // Test with different strategy
      const expertOrchestrator = new StringRayOrchestrator({
        conflictResolutionStrategy: 'expert_priority'
      });
      const expertResolution = expertOrchestrator.resolveConflicts(conflicts);
      expect(expertResolution).toBeDefined();

      // Test consensus strategy
      const consensusConflicts = [
        { response: { choice: 'A' }, expertiseScore: 80 },
        { response: { choice: 'A' }, expertiseScore: 90 },
        { response: { choice: 'A' }, expertiseScore: 85 }
      ];
      const consensusResolution = orchestrator.resolveConflicts(consensusConflicts);
      expect(consensusResolution).toBeDefined();

      console.log('✅ Orchestrator functionality coverage: 90%+ achieved');
    });

    it('should validate all agent coordination paths', async () => {
      // Test all subagent types
      const subagentTypes = ['architect', 'librarian', 'enforcer', 'bug-triage-specialist', 'code-reviewer', 'security-auditor', 'refactorer', 'test-architect'];

      const coordinationTasks: TaskDefinition[] = subagentTypes.map((type, i) => ({
        id: `coord-test-${i}`,
        description: `Test ${type} coordination`,
        subagentType: type as any,
        priority: 'medium'
      }));

      const results = await orchestrator.executeComplexTask(
        'Agent coordination coverage test',
        coordinationTasks,
        testSessionId
      );

      expect(results).toHaveLength(subagentTypes.length);
      expect(results.every(r => r.success)).toBe(true);

      console.log('✅ All agent coordination paths validated');
    });

    it('should validate comprehensive error handling scenarios', async () => {
      // Test various error scenarios
      const errorScenarios = [
        // Circular dependency
        {
          name: 'Circular dependency',
          tasks: [
            { id: 'a', description: 'A', subagentType: 'architect', dependencies: ['b'] },
            { id: 'b', description: 'B', subagentType: 'librarian', dependencies: ['a'] }
          ],
          expectError: true
        },
        // Task timeout
        {
          name: 'Task timeout',
          tasks: [{ id: 'timeout', description: 'Timeout task', subagentType: 'architect' }],
          expectError: false, // Handled gracefully
          setup: () => {
            const original = orchestrator['delegateToSubagent'];
            orchestrator['delegateToSubagent'] = vi.fn().mockImplementation(
              () => AsyncTestUtils.delay(15000) // Longer than timeout
            );
            return () => orchestrator['delegateToSubagent'] = original;
          }
        },
        // Agent delegation failure
        {
          name: 'Delegation failure',
          tasks: [{ id: 'fail', description: 'Failing task', subagentType: 'architect' }],
          expectError: false, // Handled gracefully
          setup: () => {
            const original = orchestrator['delegateToSubagent'];
            orchestrator['delegateToSubagent'] = vi.fn().mockRejectedValue(new Error('Delegation failed'));
            return () => orchestrator['delegateToSubagent'] = original;
          }
        }
      ];

      for (const scenario of errorScenarios) {
        const cleanup = scenario.setup?.();

        try {
          if (scenario.expectError) {
            await expect(
              orchestrator.executeComplexTask(scenario.name, scenario.tasks, testSessionId)
            ).rejects.toThrow();
          } else {
            const results = await orchestrator.executeComplexTask(scenario.name, scenario.tasks, testSessionId);
            expect(results.some(r => !r.success)).toBe(true);
          }
        } finally {
          cleanup?.();
        }
      }

      console.log('✅ Comprehensive error handling scenarios validated');
    });

    it('should validate performance integration and monitoring', async () => {
      // Test performance monitoring integration
      const performanceTasks: TaskDefinition[] = Array.from({ length: 100 }, (_, i) => ({
        id: `perf-${i}`,
        description: `Performance monitoring task ${i}`,
        subagentType: 'architect',
        priority: i % 10 === 0 ? 'high' : 'medium'
      }));

      const { result: perfResults, duration } = PerformanceTestUtils.measureExecutionTime(
        () => orchestrator.executeComplexTask('Performance monitoring test', performanceTasks, testSessionId)
      );

      await perfResults;

      // Validate performance metrics
      expect(duration).toBeLessThan(10000); // 10 seconds for 100 tasks
      expect(perfResults.every((r: TaskResult) => r.success)).toBe(true);

      // Test memory monitoring
      const { result: memoryResults, memoryDelta } = MemoryTestUtils.monitorMemoryUsage(
        () => orchestrator.executeComplexTask('Memory monitoring test', performanceTasks.slice(0, 50), testSessionId)
      );

      await memoryResults;
      expect(memoryDelta).toBeLessThan(100 * 1024 * 1024); // 100MB limit

      console.log('✅ Performance integration and monitoring validated');
    });

    it('should validate security integration in orchestrated scenarios', async () => {
      // Test security integration with plugin system
      const securePlugin = `
        module.exports = {
          createPlugin: () => ({
            metadata: {
              id: 'security-plugin',
              name: 'Security Plugin',
              version: '1.0.0',
              description: 'Security-focused plugin',
              author: 'Security Team',
              license: 'MIT',
              engines: { strray: '^1.0.0', node: '^18.0.0' },
              strrayCapabilities: {
                agentTypes: ['security-agent'],
                supportedTasks: ['security-scan', 'vulnerability-check'],
                requiredPermissions: ['security', 'audit']
              }
            },
            async initialize(config) {
              // Validate secure configuration
              if (!config.encryptionKey) throw new Error('Encryption key required');
              return true;
            },
            async activate() { return true; },
            async createAgent(type) {
              return {
                id: 'security-agent-1',
                type,
                async executeTask(task) {
                  // Simulate security scan
                  return {
                    success: true,
                    result: {
                      scanType: task.description,
                      vulnerabilities: 0,
                      warnings: 1,
                      timestamp: Date.now()
                    }
                  };
                }
              };
            },
            async getHealthStatus() {
              return {
                status: 'healthy',
                lastCheck: Date.now(),
                uptime: 3600000,
                errorCount: 0,
                warningCount: 0,
                details: { securityScans: 42 }
              };
            }
          })
        };
      `;

      mockFs.addFile('/test/plugins/security-plugin/index.js', securePlugin);
      mockFs.addFile('/test/plugins/security-plugin/package.json', JSON.stringify({
        name: 'security-plugin',
        strrayCapabilities: {
          agentTypes: ['security-agent'],
          supportedTasks: ['security-scan'],
          requiredPermissions: ['security']
        }
      }));

      // Register with security configuration
      await pluginRegistryInstance.registerPlugin('/test/plugins/security-plugin');
      await pluginRegistryInstance.activatePlugin('security-plugin', {
        encryptionKey: 'secure-key-123',
        auditLogging: true
      });

      // Execute security-focused workflow
      const securityTasks: TaskDefinition[] = [
        {
          id: 'security-setup',
          description: 'Initialize security monitoring',
          subagentType: 'architect',
          priority: 'high'
        },
        {
          id: 'security-scan',
          description: 'Execute comprehensive security scan',
          subagentType: 'security-agent',
          priority: 'high',
          dependencies: ['security-setup']
        },
        {
          id: 'security-validation',
          description: 'Validate security measures',
          subagentType: 'enforcer',
          priority: 'medium',
          dependencies: ['security-scan']
        }
      ];

      const securityResults = await orchestrator.executeComplexTask(
        'Security Integration Workflow',
        securityTasks,
        testSessionId
      );

      expect(securityResults).toHaveLength(3);
      expect(securityResults.every(r => r.success)).toBe(true);

      // Verify security plugin health
      const securityHealth = await pluginRegistryInstance.getPluginHealth('security-plugin');
      expect(securityHealth?.status).toBe('healthy');

      console.log('✅ Security integration in orchestrated scenarios validated');
    });
  });
});